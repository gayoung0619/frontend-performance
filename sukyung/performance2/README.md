# 2월 첫째주 성능 최적화 과제 : 이미지 렌더링 최적화

## 1. 문제 상황

이미지 리스트에서 각각의 이미지들은 고해상도이며 5000 × 5000 크기를 갖고 있다.
이로 인해 LCP와 TBT가 에러가 날 정도로 성능에 문제가 있었다.
![](https://velog.velcdn.com/images/oaksusu/post/5469a1ed-a627-44f8-806f-d2e175cf2e42/image.png)

## 2. 문제 해결 과정

### 2-1. 이미지 압축

: 이미지 압축시켜주는 사이트에서 압축시켜서 용량을 7% 줄였지만(2.33 MB -> 2.17 MB)
lighthouse에서 측정한 성능 점수는 동일하며, LCP와 TBT를 개선시키지 못했다.

### 2-2. 확장자 변환

기존 이미지는 jpg였으나, webp로 변환하여 성능 측정결과 speed index는 0.1s 줄었지만 나머지는 변화가 없었다.

### 2-3. 기존의 LCP 개선

구글링을 통해 읽은 글에서 앞서 적용해보았던 방법들인, 이미지 압축과 이미지 확장자를 바꿔보는 방법은 기존의 개선 방법이며, 실제로 성능을 크게 개선시키지 않는다는 것을 알게 되었다. 즉, 이미지를 다운로드함으로써 병목현상이 발생하는 경우는 극히 드물다고 한다. [참고한 글](https://web.dev/blog/common-misconceptions-lcp?hl=ko)

---

> 2-4부터는 큰 이미지(5000x5000)를 저장해서 불러온 방식에서 api로 고해상도이며 사이즈가 큰 이미지 리스트를 불러와서 사용했다. 실제로 작업할땐 이런 방식보다 api 방식으로 이미지를 불러오는 것이 좀 더 현실적인 것 같아서 이미지 불러오는 방식을 변경했다.

```
// 기존 방식
  const images = Array.from({ length: 100 }, (_, index) => (
    <img key={index} src={image} width="100%" loading="lazy" />
  ));
```

```
// 새로운 방식
const Images = () => {
  const fetcImages = () => {
    return fetch('https://picsum.photos/v2/list').then((res) => res.json());
  };

  const { data } = useQuery({
    queryKey: ['images'],
    queryFn: () => fetcImages(),
  });

  if (!data) return;

  console.log(data);
  return (
    <div>
      {data.map((image) => (
        <img key={image.id} src={image.download_url} width="100%" />
      ))}
    </div>
  );
};
```

변경한 방식으로 성능 측정한 점수
![](https://velog.velcdn.com/images/oaksusu/post/4f161920-9e80-4f25-9682-1dadfaa652a3/image.png)

### 2-4. 이미지 사이즈 조정

이미지가 해상도에 따라 width: 100%일 경우에는 LCP와 TBT를 측정할 수가 없고 해결이 가능한 부분이 아니라고 판단했다.
만약에 실무에서 이와 같은 요구사항이 있을 경우 이미지가 과도하게 큰 사이즈이고 고해상도일 경우 성능에 문제가 있음을 사전에 얘기하고, 이미지 사이즈를 조정할 수 있는 방안으로 협의를 해야겠다고 생각했다.

**[이미지 사이즈 조정 방법]**

1. 해상도에 따라 가로,세로를 px 사이즈를 정해두고 반응형으로 대응하는 방법
2. aspect-ratio를 사용하여 해상도에 맞춰 가로 값을 100%로 하되 높이값은 가로에 대한 비율로 정해두는 방법

**[채택 기준]**
2번째 방법은 해상도에 맞는 width를 사용할 수 있다는 점에서 채택하게 되었다.

**[결과]**
aspect-ratio: video로 적용한 결과 성능 점수를 개선시킬 수 있었다. (16:9 비율)
![](https://velog.velcdn.com/images/oaksusu/post/b4c1889a-ad64-4759-8def-e91d3043b7d6/image.png)

### 2-5. loading="lazy" 속성 적용

뷰포트내에 들어오지 않는 이미지들은 나중에 렌더링되도록 이미지한테 loading="lazy"속성을 적용시켜보았지만, 점수에 별차이가 없었다.
![](https://velog.velcdn.com/images/oaksusu/post/7feb3415-a8a1-4a47-8a12-03b3bce9d51a/image.png)

### 2-5. IntersectionObserver API

이번엔 속성만 적용시키는 것이 아닌, 뷰포트안에 들어오면 렌더링되도록 IntersectionObserver API를 이용해서 기능적으로 구현해봤다. 점수가 크게 개선되었다.
![](https://velog.velcdn.com/images/oaksusu/post/a9c5cf89-4ece-4667-9e33-11865ba95e04/image.png)

### 2-6. 중간점검

한번 중간점검해보고자, 빌드 후 다시 점수를 측정해보았다.
여전히 LCP는 개선이 필요해 보이지만 90점대가 나왔다.
![](https://velog.velcdn.com/images/oaksusu/post/d7103e22-dc0b-4552-ada4-c12a89102de1/image.png)

성능 점수는 개선시켰지만, 중간에 이미지들이 로드되기 전에 빈화면이 보이는게 UX에 좋지 않다고 생각했다.
![](https://velog.velcdn.com/images/oaksusu/post/030f1716-101f-4d0a-bdaf-7d5d23fea94c/image.gif)

### 2-7. 스켈레톤 개선

앞서 중간 점검에서 UX가 좋지 않아서 스켈레톤을 추가해보았다. 그러나 스켈레톤이 적용된 모습을 확인하기가 어려웠는데,
img의 로드 이벤트를 활용했더니 로드 되기전까지 스켈레톤이 대체해서 보여졌고 UX는 훨씬 나아졌다.

그러나! 성능 점수는 다시 70점대로 내려갔다...
![](https://velog.velcdn.com/images/oaksusu/post/0b4b45a5-2b97-42e7-9920-f0fa2262ffdf/image.png)

## 3. 다른 방법은 더 없을까?

### srcSet 속성

성능 개선 스터디에서 다른 팀원이 srcSet 속성을 사용하여 성능 개선시킨 사례가 있었다.
그래서 해당 방법을 사용해보려 했지만, 팀원분과 내가 이미지를 사용하는 방식이 달라서 srcSet을 활용할 수가 없었다.
팀원분은 100개의 이미지들을 해상도에 따라서 사이즈를 지정해서 100번의 api요청을 보내 불러왔고,
나는 한번의 api로 가져온 이미지들을 사용하는데, 그 이미지들은 사이즈를 지정할 수가 없고 원본 사이즈(대부분 3000사이즈 이상이였다)로만 사용할 수 있었다.

- 이 방법은 이미지가 많지 않고, 동일한 이미지를 사이즈별로 CDN에 올려두는 환경에서 적합한 방법일것 같다라는 결론을 내렸다.

## 4. 결론

이미지의 사이즈나 `비율(aspect-ratio)`을 지정하고, 뷰포트내에 있을때만 렌더링시키는 방법(`intersectionObserver API`)을 사용해서
이미지 리스트들을 렌더링하는데 있어서 성능을 개선시킬 수 있었다.
이러한 기술적 접근은 전반적인 성능 향상에 기여했지만, 여전히 이미지 로딩에 시간이 소요되는 문제가 있었다.

이 시점에서 두 가지 선택지가 있다.

1. 빈 화면을 그대로 보여주며 성능 점수를 유지
2. 스켈레톤 UI나 대체 이미지를 보여주되 성능 점수를 감수
   이런 상황에서 나는 후자, 즉 사용자 경험을 우선시하는 접근을 선택할 것이다.

그 이유는 모든 사용자가 최적화된 환경에서 웹사이트를 이용하는 것이 아니기 때문이다.
높은 성능 점수를 획득하더라도, 실제로 다양한 네트워크 환경에서 사용자들이 마주하게 되는 것은 의미 없는 빈 화면일 수 있다.
대신 "여기에 곧 이미지가 로드될 것입니다"라는 명확한 시각적 피드백을 제공하는 것이, 웹사이트에 대한 긍정적인 첫인상을 남기고 재방문율을 높이는 데 더 효과적일 것이라고 생각한다.
결과적으로 사용자들에게 더 나은 경험을 제공하는 것이, 순간적인 성능 지표보다 웹사이트의 가치를 더 높이는 선택이 될 것이라고 생각한다.
